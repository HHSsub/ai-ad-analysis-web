// src/app/api/analyze/route.ts - Ï†ÑÎ©¥ ÏàòÏ†ï
import { NextRequest, NextResponse } from 'next/server';
import { google } from 'googleapis';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { getSubtitles } from 'youtube-captions-scraper';
import { getGlobalDB } from '@/lib/sql-database';
import { VIDEO_FEATURES } from '@/types/video';
import { calculateHybridScore } from '@/services/metricsService';
import fs from 'fs';
import path from 'path';

// CSVÏóêÏÑú ÌäπÏÑ± Î°úÎìú
interface Feature {
  No: string;
  Category: string;
  Feature: string;
  Value: string;
}

function getFeaturesFromCSV(): Feature[] {
  try {
    const csvPath = path.join(process.cwd(), 'public', 'youtube_ad_features.csv');
    const csvContent = fs.readFileSync(csvPath, 'utf-8');
    const lines = csvContent.split('\n').filter(line => line.trim());
    
    const features: Feature[] = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = parseCsvLine(lines[i]);
      if (cols.length >= 3) {
        features.push({
          No: cols[0],
          Category: cols[1],
          Feature: cols[2],
          Value: cols[3] || ''
        });
      }
    }
    
    console.log(`‚úÖ CSV Î°úÎìú: ${features.length}Í∞ú ÌäπÏÑ±`);
    return features;
  } catch {
    console.log('‚ö†Ô∏è CSV Ìè¥Î∞±: VIDEO_FEATURES ÏÇ¨Ïö©');
    return VIDEO_FEATURES.map(f => ({
      No: f.no,
      Category: f.category,
      Feature: f.item,
      Value: ''
    }));
  }
}

function parseCsvLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }
  result.push(current);
  return result.map(col => col.trim());
}

// YouTube API
function getYouTubeVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/
  ];
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

// ÏûêÎßâ Ï∂îÏ∂ú
async function extractSubtitles(videoId: string) {
  try {
    const captions = await getSubtitles({ videoID: videoId, lang: 'ko' });
    const fullText = captions.map((c: any) => c.text).join(' ');
    return { language: 'ko', text: fullText };
  } catch {
    try {
      const captions = await getSubtitles({ videoID: videoId, lang: 'en' });
      const fullText = captions.map((c: any) => c.text).join(' ');
      return { language: 'en', text: fullText };
    } catch {
      return { language: 'none', text: '' };
    }
  }
}

// Gemini API ÌÇ§ Î°úÎìú
function getGeminiApiKeys(): string[] {
  const key = process.env.GEMINI_API_KEY;
  if (!key) return [];
  return key.split(',').map(k => k.trim()).filter(Boolean);
}

// Gemini ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
function buildGeminiPrompt(videoData: any, scriptData: any, features: Feature[]): string {
  const { snippet, statistics, contentDetails } = videoData;
  
  const getDurationInSeconds = (duration: string): number => {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;
    const [, hours = '0', minutes = '0', seconds = '0'] = match;
    return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(seconds);
  };

  const durationSeconds = getDurationInSeconds(contentDetails?.duration || '');
  const isShortVideo = durationSeconds <= 60;

  const categorizedFeatures = features.reduce((acc, feature) => {
    if (!acc[feature.Category]) {
      acc[feature.Category] = [];
    }
    acc[feature.Category].push(`${feature.No}. ${feature.Feature}`);
    return acc;
  }, {} as Record<string, string[]>);

  const featuresText = Object.entries(categorizedFeatures)
    .map(([category, items]) => `${category}:\n${items.join('\n')}`)
    .join('\n\n');

  return `
# YouTube Video Analysis Expert

**Video Type:** ${isShortVideo ? 'SHORT (‚â§60s)' : 'STANDARD (>60s)'}
**Duration:** ${durationSeconds}s
**Title:** ${snippet?.title || 'N/A'}
**Channel:** ${snippet?.channelTitle || 'N/A'}
**Views:** ${statistics?.viewCount || 'N/A'}
**Script:** ${scriptData.text ? scriptData.text.substring(0, 300) + '...' : 'No script'}

## Analysis Features (156):
${featuresText}

## Instructions:
1. Provide specific, evidence-based analysis
2. For short videos, focus on immediate visual impact
3. Use "Î∂ÑÏÑùÎ∂àÍ∞Ä/reason" only when truly impossible
4. Make educated guesses based on visual/audio cues

## Response Format (JSON):
{
  "feature_1": "analyzed value or Î∂ÑÏÑùÎ∂àÍ∞Ä/reason",
  "feature_2": "analyzed value or Î∂ÑÏÑùÎ∂àÍ∞Ä/reason",
  ...
  "feature_156": "analyzed value or Î∂ÑÏÑùÎ∂àÍ∞Ä/reason"
}`.trim();
}

// Gemini AI Ìò∏Ï∂ú
async function callGeminiWithFallback(prompt: string, apiKeys: string[], retries: number = 3): Promise<any> {
  let lastError: any = null;

  for (let attempt = 0; attempt < retries; attempt++) {
    for (const apiKey of apiKeys) {
      try {
        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({ model: 'gemini-1.5-pro' });
        
        const result = await model.generateContent(prompt);
        const responseText = result.response.text();
        
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          return JSON.parse(jsonMatch[0]);
        }
        
        console.warn(`‚ö†Ô∏è JSON ÌååÏã± Ïã§Ìå® (ÌÇ§ ${apiKey.substring(0, 8)}...)`);
      } catch (error: any) {
        lastError = error;
        console.warn(`‚ö†Ô∏è Gemini Ìò∏Ï∂ú Ïã§Ìå® (${attempt + 1}/${retries}):`, error.message);
      }
    }
    
    if (attempt < retries - 1) {
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }

  throw lastError || new Error('All Gemini API attempts failed');
}

// YouTube Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Ï∂îÎ°†
function inferFeaturesFromYouTubeMetadata(videoData: any, features: Feature[]): any {
  const { snippet, statistics, contentDetails } = videoData;
  const result: any = {};
  
  features.forEach(feature => {
    const featureKey = `feature_${feature.No}`;
    
    if (feature.Feature.includes('ÏòÅÏÉÅ Ï†úÎ™©') || feature.Feature.includes('Ï†úÎ™©')) {
      result[featureKey] = snippet?.title || 'N/A';
    } else if (feature.Feature.includes('Ï±ÑÎÑê')) {
      result[featureKey] = snippet?.channelTitle || 'N/A';
    } else if (feature.Feature.includes('Ï°∞ÌöåÏàò')) {
      result[featureKey] = statistics?.viewCount ? parseInt(statistics.viewCount).toLocaleString() : '0';
    } else if (feature.Feature.includes('Ï¢ãÏïÑÏöî')) {
      result[featureKey] = statistics?.likeCount ? parseInt(statistics.likeCount).toLocaleString() : '0';
    } else if (feature.Feature.includes('ÎåìÍ∏Ä')) {
      result[featureKey] = statistics?.commentCount ? parseInt(statistics.commentCount).toLocaleString() : '0';
    } else if (feature.Feature.includes('ÏòÅÏÉÅ Í∏∏Ïù¥') || feature.Feature.includes('Ï†ÑÏ≤¥ ÏòÅÏÉÅ Í∏∏Ïù¥')) {
      if (contentDetails?.duration) {
        const match = contentDetails.duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
        if (match) {
          const [, h = '0', m = '0', s = '0'] = match;
          result[featureKey] = `${h}ÏãúÍ∞Ñ ${m}Î∂Ñ ${s}Ï¥à`;
        }
      }
    } else if (feature.Feature.includes('ÏóÖÎ°úÎìú')) {
      result[featureKey] = snippet?.publishedAt || 'N/A';
    }
  });
  
  return result;
}

// ÏôÑÎ£åÎèÑ Í≥ÑÏÇ∞
function calculateCompletionStats(analysis: any) {
  let completed = 0;
  let incomplete = 0;
  const total = 156;

  Object.keys(analysis).forEach(key => {
    const value = String(analysis[key] || '');
    if (value.includes('Î∂ÑÏÑùÎ∂àÍ∞Ä') || value === 'N/A' || value === '') {
      incomplete++;
    } else {
      completed++;
    }
  });

  return {
    completed,
    incomplete,
    total,
    percentage: Math.round((completed / total) * 100)
  };
}

// Îã®Ïùº ÏòÅÏÉÅ Î∂ÑÏÑù
async function analyzeSingleVideo(video: any, features: Feature[], youtube: any | null, apiKeys: string[]): Promise<any> {
  const videoId = getYouTubeVideoId(video.url);
  if (!videoId) throw new Error(`Invalid YouTube URL: ${video.url}`);

  console.log(`üé¨ Î∂ÑÏÑù ÏãúÏûë: ${video.title}`);

  // YouTube Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏàòÏßë
  let videoData: any = null;
  if (youtube) {
    try {
      const response = await youtube.videos.list({
        part: ['snippet', 'statistics', 'contentDetails'],
        id: [videoId],
      });
      if (response.data.items && response.data.items.length > 0) {
        videoData = response.data.items[0];
      }
    } catch (error) {
      console.log('‚ö†Ô∏è YouTube API Ïò§Î•ò');
    }
  }

  if (!videoData) {
    videoData = {
      snippet: { title: video.title, description: '', channelTitle: 'N/A', publishedAt: '' },
      statistics: { viewCount: '', likeCount: '', commentCount: '' },
      contentDetails: { duration: '' }
    };
  }

  // ÏûêÎßâ Ï∂îÏ∂ú
  const scriptData = await extractSubtitles(videoId);

  // YouTube Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Ï∂îÎ°†
  const baseInferences = inferFeaturesFromYouTubeMetadata(videoData, features);
  console.log(`üìä Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Î°ú ${Object.keys(baseInferences).length}Í∞ú Ï±ÑÏõÄ`);

  // Gemini AI Î∂ÑÏÑù
  let geminiAnalysis: any = {};
  let geminiErrorReason: string | null = null;

  if (apiKeys.length > 0) {
    try {
      const prompt = buildGeminiPrompt(videoData, scriptData, features);
      geminiAnalysis = await callGeminiWithFallback(prompt, apiKeys);
      console.log(`‚úÖ Gemini Î∂ÑÏÑù ÏôÑÎ£å: ${Object.keys(geminiAnalysis).length}Í∞ú`);
    } catch (error: any) {
      geminiErrorReason = error.message;
      console.log('‚ö†Ô∏è Gemini Î∂ÑÏÑù Ïã§Ìå®:', error.message);
    }
  }

  // Í≤∞Í≥º Î≥ëÌï©
  const finalAnalysis: any = {};
  features.forEach(feature => {
    const key = `feature_${feature.No}`;
    finalAnalysis[key] = geminiAnalysis[key] || baseInferences[key] || 'N/A';
  });

  // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ï†ïÎ¶¨
  const categorizedAnalysis: any = {};
  features.forEach(feature => {
    if (!categorizedAnalysis[feature.Category]) {
      categorizedAnalysis[feature.Category] = {};
    }
    categorizedAnalysis[feature.Category][feature.Feature] = finalAnalysis[`feature_${feature.No}`];
  });

  const completionStats = calculateCompletionStats(finalAnalysis);

  return {
    id: videoId,
    title: video.title,
    url: video.url,
    notes: video.note || '',
    status: completionStats.percentage > 5 ? 'completed' : 'failed',
    analysis: categorizedAnalysis,
    features: finalAnalysis,
    completionStats,
    scriptLanguage: scriptData.language,
    youtubeData: {
      viewCount: parseInt(videoData.statistics?.viewCount || '0'),
      likeCount: parseInt(videoData.statistics?.likeCount || '0'),
      commentCount: parseInt(videoData.statistics?.commentCount || '0'),
      duration: videoData.contentDetails?.duration || '',
      channelTitle: videoData.snippet?.channelTitle || '',
      publishedAt: videoData.snippet?.publishedAt || '',
      description: videoData.snippet?.description || '',
      tags: [],
      categoryId: ''
    }
  };
}

// Î©îÏù∏ POST Ìï∏Îì§Îü¨
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { videos } = body;

    if (!videos || !Array.isArray(videos) || videos.length === 0) {
      return NextResponse.json({ message: 'Î∂ÑÏÑùÌï† ÏòÅÏÉÅ Î™©Î°ùÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.' }, { status: 400 });
    }

    const features = getFeaturesFromCSV();
    console.log(`üéØ Î∂ÑÏÑù ÏãúÏûë: ${videos.length}Í∞ú ÏòÅÏÉÅ, ${features.length}Í∞ú ÌäπÏÑ±`);

    // YouTube API Ï¥àÍ∏∞Ìôî
    let youtube = null;
    const youtubeApiKey = process.env.YOUTUBE_API_KEY;
    if (youtubeApiKey) {
      youtube = google.youtube({ version: 'v3', auth: youtubeApiKey });
      console.log('‚úÖ YouTube API Ï¥àÍ∏∞Ìôî');
    }

    // Gemini API ÌÇ§ Î°úÎìú
    const geminiApiKeys = getGeminiApiKeys();

    // SQL DB Ï¥àÍ∏∞Ìôî
    const db = getGlobalDB();

    const results: any[] = [];

    for (let i = 0; i < videos.length; i++) {
      const video = videos[i];
      
      try {
        // ÏòÅÏÉÅ Î∂ÑÏÑù
        const result = await analyzeSingleVideo(video, features, youtube, geminiApiKeys);
        
        // ÌïòÏù¥Î∏åÎ¶¨Îìú Ï†êÏàò Í≥ÑÏÇ∞
        const hybridScore = calculateHybridScore({
          ...result,
          createdAt: new Date().toISOString()
        });
        result.hybridScore = hybridScore;

        // SQL DBÏóê Ï†ÄÏû•
        db.saveAnalysisResult({
          ...result,
          createdAt: new Date().toISOString()
        });

        results.push(result);
        console.log(`‚úÖ ÏòÅÏÉÅ ${i + 1}/${videos.length} ÏôÑÎ£å: ${video.title}`);
        
        if (i < videos.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      } catch (error: any) {
        console.error(`‚ùå ÏòÅÏÉÅ Î∂ÑÏÑù Ïã§Ìå® [${video.title}]:`, error.message);
        
        const videoId = getYouTubeVideoId(video.url);
        if (videoId) {
          db.markAnalysisFailed(videoId, error.message);
        }
        
        results.push({
          status: 'rejected',
          reason: error.message,
          url: video.url
        });
      }
    }

    console.log(`üéâ Ï†ÑÏ≤¥ Î∂ÑÏÑù ÏôÑÎ£å: ${results.length}Í∞ú`);

    return NextResponse.json({
      message: 'Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.',
      results,
      stats: db.getStatistics()
    });

  } catch (error: any) {
    console.error('‚ùå API Ïò§Î•ò:', error);
    return NextResponse.json(
      { message: 'Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', error: error.message },
      { status: 500 }
    );
  }
}
